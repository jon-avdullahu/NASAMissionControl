{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) {\n  return typeof obj;\n} : function (obj) {\n  return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n};\nexports.default = jssExpand;\nvar _props = require('./props');\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n  return obj;\n}\n\n/**\n * Map values by given prop.\n *\n * @param {Array} array of values\n * @param {String} original property\n * @param {String} original rule\n * @return {String} mapped values\n */\nfunction mapValuesByProp(value, prop, rule) {\n  return value.map(function (item) {\n    return objectToArray(item, prop, rule, false, true);\n  });\n}\n\n/**\n * Convert array to nested array, if needed\n *\n * @param {Array} array of values\n * @param {String} original property\n * @param {Object} sheme, for converting arrays in strings\n * @param {Object} original rule\n * @return {String} converted string\n */\nfunction processArray(value, prop, scheme, rule) {\n  if (scheme[prop] == null) return value;\n  if (value.length === 0) return [];\n  if (Array.isArray(value[0])) return processArray(value[0], prop, scheme);\n  if (_typeof(value[0]) === 'object') {\n    return mapValuesByProp(value, prop, rule);\n  }\n  return [value];\n}\n\n/**\n * Convert object to array.\n *\n * @param {Object} object of values\n * @param {String} original property\n * @param {Object} original rule\n * @param {Boolean} is fallback prop\n * @param {Boolean} object is inside array\n * @return {String} converted string\n */\nfunction objectToArray(value, prop, rule, isFallback, isInArray) {\n  if (!(_props.propObj[prop] || _props.customPropObj[prop])) return [];\n  var result = [];\n\n  // Check if exists any non-standart property\n  if (_props.customPropObj[prop]) {\n    value = customPropsToStyle(value, rule, _props.customPropObj[prop], isFallback);\n  }\n\n  // Pass throught all standart props\n  if (Object.keys(value).length) {\n    for (var baseProp in _props.propObj[prop]) {\n      if (value[baseProp]) {\n        if (Array.isArray(value[baseProp])) {\n          result.push(_props.propArrayInObj[baseProp] === null ? value[baseProp] : value[baseProp].join(' '));\n        } else result.push(value[baseProp]);\n        continue;\n      }\n\n      // Add default value from props config.\n      if (_props.propObj[prop][baseProp] != null) {\n        result.push(_props.propObj[prop][baseProp]);\n      }\n    }\n  }\n  if (!result.length || isInArray) return result;\n  return [result];\n}\n\n/**\n * Convert custom properties values to styles adding them to rule directly\n *\n * @param {Object} object of values\n * @param {Object} original rule\n * @param {String} property, that contain partial custom properties\n * @param {Boolean} is fallback prop\n * @return {Object} value without custom properties, that was already added to rule\n */\nfunction customPropsToStyle(value, rule, customProps, isFallback) {\n  for (var prop in customProps) {\n    var propName = customProps[prop];\n\n    // If current property doesn't exist already in rule - add new one\n    if (typeof value[prop] !== 'undefined' && (isFallback || !rule.prop(propName))) {\n      var appendedValue = styleDetector(_defineProperty({}, propName, value[prop]), rule)[propName];\n\n      // Add style directly in rule\n      if (isFallback) rule.style.fallbacks[propName] = appendedValue;else rule.style[propName] = appendedValue;\n    }\n    // Delete converted property to avoid double converting\n    delete value[prop];\n  }\n  return value;\n}\n\n/**\n * Detect if a style needs to be converted.\n *\n * @param {Object} style\n * @param {Object} rule\n * @param {Boolean} is fallback prop\n * @return {Object} convertedStyle\n */\nfunction styleDetector(style, rule, isFallback) {\n  for (var prop in style) {\n    var value = style[prop];\n    if (Array.isArray(value)) {\n      // Check double arrays to avoid recursion.\n      if (!Array.isArray(value[0])) {\n        if (prop === 'fallbacks') {\n          for (var index = 0; index < style.fallbacks.length; index++) {\n            style.fallbacks[index] = styleDetector(style.fallbacks[index], rule, true);\n          }\n          continue;\n        }\n        style[prop] = processArray(value, prop, _props.propArray);\n        // Avoid creating properties with empty values\n        if (!style[prop].length) delete style[prop];\n      }\n    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      if (prop === 'fallbacks') {\n        style.fallbacks = styleDetector(style.fallbacks, rule, true);\n        continue;\n      }\n      style[prop] = objectToArray(value, prop, rule, isFallback);\n      // Avoid creating properties with empty values\n      if (!style[prop].length) delete style[prop];\n    }\n\n    // Maybe a computed value resulting in an empty string\n    else if (style[prop] === '') delete style[prop];\n  }\n  return style;\n}\n\n/**\n * Adds possibility to write expanded styles.\n *\n * @param {Rule} rule\n * @api public\n */\nfunction jssExpand() {\n  function onProcessStyle(style, rule) {\n    if (!style || rule.type !== 'style') return style;\n    if (Array.isArray(style)) {\n      // Pass rules one by one and reformat them\n      for (var index = 0; index < style.length; index++) {\n        style[index] = styleDetector(style[index], rule);\n      }\n      return style;\n    }\n    return styleDetector(style, rule);\n  }\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_typeof","Symbol","iterator","obj","constructor","prototype","default","jssExpand","_props","require","_defineProperty","key","enumerable","configurable","writable","mapValuesByProp","prop","rule","map","item","objectToArray","processArray","scheme","length","Array","isArray","isFallback","isInArray","propObj","customPropObj","result","customPropsToStyle","keys","baseProp","push","propArrayInObj","join","customProps","propName","appendedValue","styleDetector","style","fallbacks","index","propArray","onProcessStyle","type"],"sources":["/Users/jonavdullahu/Desktop/Programim/NASA-PROJECT/client/node_modules/jss-expand/lib/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nexports.default = jssExpand;\n\nvar _props = require('./props');\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Map values by given prop.\n *\n * @param {Array} array of values\n * @param {String} original property\n * @param {String} original rule\n * @return {String} mapped values\n */\nfunction mapValuesByProp(value, prop, rule) {\n  return value.map(function (item) {\n    return objectToArray(item, prop, rule, false, true);\n  });\n}\n\n/**\n * Convert array to nested array, if needed\n *\n * @param {Array} array of values\n * @param {String} original property\n * @param {Object} sheme, for converting arrays in strings\n * @param {Object} original rule\n * @return {String} converted string\n */\nfunction processArray(value, prop, scheme, rule) {\n  if (scheme[prop] == null) return value;\n  if (value.length === 0) return [];\n  if (Array.isArray(value[0])) return processArray(value[0], prop, scheme);\n  if (_typeof(value[0]) === 'object') {\n    return mapValuesByProp(value, prop, rule);\n  }\n\n  return [value];\n}\n\n/**\n * Convert object to array.\n *\n * @param {Object} object of values\n * @param {String} original property\n * @param {Object} original rule\n * @param {Boolean} is fallback prop\n * @param {Boolean} object is inside array\n * @return {String} converted string\n */\nfunction objectToArray(value, prop, rule, isFallback, isInArray) {\n  if (!(_props.propObj[prop] || _props.customPropObj[prop])) return [];\n\n  var result = [];\n\n  // Check if exists any non-standart property\n  if (_props.customPropObj[prop]) {\n    value = customPropsToStyle(value, rule, _props.customPropObj[prop], isFallback);\n  }\n\n  // Pass throught all standart props\n  if (Object.keys(value).length) {\n    for (var baseProp in _props.propObj[prop]) {\n      if (value[baseProp]) {\n        if (Array.isArray(value[baseProp])) {\n          result.push(_props.propArrayInObj[baseProp] === null ? value[baseProp] : value[baseProp].join(' '));\n        } else result.push(value[baseProp]);\n        continue;\n      }\n\n      // Add default value from props config.\n      if (_props.propObj[prop][baseProp] != null) {\n        result.push(_props.propObj[prop][baseProp]);\n      }\n    }\n  }\n\n  if (!result.length || isInArray) return result;\n  return [result];\n}\n\n/**\n * Convert custom properties values to styles adding them to rule directly\n *\n * @param {Object} object of values\n * @param {Object} original rule\n * @param {String} property, that contain partial custom properties\n * @param {Boolean} is fallback prop\n * @return {Object} value without custom properties, that was already added to rule\n */\nfunction customPropsToStyle(value, rule, customProps, isFallback) {\n  for (var prop in customProps) {\n    var propName = customProps[prop];\n\n    // If current property doesn't exist already in rule - add new one\n    if (typeof value[prop] !== 'undefined' && (isFallback || !rule.prop(propName))) {\n      var appendedValue = styleDetector(_defineProperty({}, propName, value[prop]), rule)[propName];\n\n      // Add style directly in rule\n      if (isFallback) rule.style.fallbacks[propName] = appendedValue;else rule.style[propName] = appendedValue;\n    }\n    // Delete converted property to avoid double converting\n    delete value[prop];\n  }\n\n  return value;\n}\n\n/**\n * Detect if a style needs to be converted.\n *\n * @param {Object} style\n * @param {Object} rule\n * @param {Boolean} is fallback prop\n * @return {Object} convertedStyle\n */\nfunction styleDetector(style, rule, isFallback) {\n  for (var prop in style) {\n    var value = style[prop];\n\n    if (Array.isArray(value)) {\n      // Check double arrays to avoid recursion.\n      if (!Array.isArray(value[0])) {\n        if (prop === 'fallbacks') {\n          for (var index = 0; index < style.fallbacks.length; index++) {\n            style.fallbacks[index] = styleDetector(style.fallbacks[index], rule, true);\n          }\n          continue;\n        }\n\n        style[prop] = processArray(value, prop, _props.propArray);\n        // Avoid creating properties with empty values\n        if (!style[prop].length) delete style[prop];\n      }\n    } else if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n      if (prop === 'fallbacks') {\n        style.fallbacks = styleDetector(style.fallbacks, rule, true);\n        continue;\n      }\n\n      style[prop] = objectToArray(value, prop, rule, isFallback);\n      // Avoid creating properties with empty values\n      if (!style[prop].length) delete style[prop];\n    }\n\n    // Maybe a computed value resulting in an empty string\n    else if (style[prop] === '') delete style[prop];\n  }\n\n  return style;\n}\n\n/**\n * Adds possibility to write expanded styles.\n *\n * @param {Rule} rule\n * @api public\n */\nfunction jssExpand() {\n  function onProcessStyle(style, rule) {\n    if (!style || rule.type !== 'style') return style;\n\n    if (Array.isArray(style)) {\n      // Pass rules one by one and reformat them\n      for (var index = 0; index < style.length; index++) {\n        style[index] = styleDetector(style[index], rule);\n      }\n      return style;\n    }\n\n    return styleDetector(style, rule);\n  }\n\n  return { onProcessStyle: onProcessStyle };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}