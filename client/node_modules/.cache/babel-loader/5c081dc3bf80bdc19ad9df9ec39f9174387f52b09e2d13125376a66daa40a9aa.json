{"ast":null,"code":"'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _extends = Object.assign || function (target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i];\n    for (var key in source) {\n      if (Object.prototype.hasOwnProperty.call(source, key)) {\n        target[key] = source[key];\n      }\n    }\n  }\n  return target;\n};\nexports.default = jssNested;\nvar _warning = require('warning');\nvar _warning2 = _interopRequireDefault(_warning);\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    default: obj\n  };\n}\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container) {\n    return function (match, key) {\n      var rule = container.getRule(key);\n      if (rule) return rule.selector;\n      (0, _warning2.default)(false, '[JSS] Could not find the referenced rule %s in %s.', key, container.options.meta || container);\n      return key;\n    };\n  }\n  var hasAnd = function hasAnd(str) {\n    return str.indexOf('&') !== -1;\n  };\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n    var result = '';\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', ';\n        // Replace all & by the parent or prefix & with the parent.\n        result += hasAnd(nested) ? nested.replace(parentRegExp, parent) : parent + ' ' + nested;\n      }\n    }\n    return result;\n  }\n  function getOptions(rule, container, options) {\n    // Options has been already created, now we only increase index.\n    if (options) return _extends({}, options, {\n      index: options.index + 1\n    });\n    var nestingLevel = rule.options.nestingLevel;\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n    return _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1\n    });\n  }\n  function onProcessStyle(style, rule) {\n    if (rule.type !== 'style') return style;\n    var container = rule.options.parent;\n    var options = void 0;\n    var replaceRef = void 0;\n    for (var prop in style) {\n      var isNested = hasAnd(prop);\n      var isNestedConditional = prop[0] === '@';\n      if (!isNested && !isNestedConditional) continue;\n      options = getOptions(rule, container, options);\n      if (isNested) {\n        var selector = replaceParentRefs(prop, rule.selector\n        // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n        );\n        if (!replaceRef) replaceRef = getReplaceRef(container\n        // Replace all $refs.\n        );\n        selector = selector.replace(refRegExp, replaceRef);\n        container.addRule(selector, style[prop], _extends({}, options, {\n          selector: selector\n        }));\n      } else if (isNestedConditional) {\n        container\n        // Place conditional right after the parent rule to ensure right ordering.\n        .addRule(prop, null, options).addRule(rule.key, style[prop], {\n          selector: rule.selector\n        });\n      }\n      delete style[prop];\n    }\n    return style;\n  }\n  return {\n    onProcessStyle: onProcessStyle\n  };\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","_extends","assign","target","i","arguments","length","source","key","prototype","hasOwnProperty","call","default","jssNested","_warning","require","_warning2","_interopRequireDefault","obj","__esModule","separatorRegExp","parentRegExp","refRegExp","getReplaceRef","container","match","rule","getRule","selector","options","meta","hasAnd","str","indexOf","replaceParentRefs","nestedProp","parentProp","parentSelectors","split","nestedSelectors","result","parent","j","nested","replace","getOptions","index","nestingLevel","undefined","onProcessStyle","style","type","replaceRef","prop","isNested","isNestedConditional","addRule"],"sources":["/Users/jonavdullahu/Desktop/Programim/NASA-PROJECT/client/node_modules/jss-nested/lib/index.js"],"sourcesContent":["'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };\n\nexports.default = jssNested;\n\nvar _warning = require('warning');\n\nvar _warning2 = _interopRequireDefault(_warning);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar separatorRegExp = /\\s*,\\s*/g;\nvar parentRegExp = /&/g;\nvar refRegExp = /\\$([\\w-]+)/g;\n\n/**\n * Convert nested rules to separate, remove them from original styles.\n *\n * @param {Rule} rule\n * @api public\n */\nfunction jssNested() {\n  // Get a function to be used for $ref replacement.\n  function getReplaceRef(container) {\n    return function (match, key) {\n      var rule = container.getRule(key);\n      if (rule) return rule.selector;\n      (0, _warning2.default)(false, '[JSS] Could not find the referenced rule %s in %s.', key, container.options.meta || container);\n      return key;\n    };\n  }\n\n  var hasAnd = function hasAnd(str) {\n    return str.indexOf('&') !== -1;\n  };\n\n  function replaceParentRefs(nestedProp, parentProp) {\n    var parentSelectors = parentProp.split(separatorRegExp);\n    var nestedSelectors = nestedProp.split(separatorRegExp);\n\n    var result = '';\n\n    for (var i = 0; i < parentSelectors.length; i++) {\n      var parent = parentSelectors[i];\n\n      for (var j = 0; j < nestedSelectors.length; j++) {\n        var nested = nestedSelectors[j];\n        if (result) result += ', ';\n        // Replace all & by the parent or prefix & with the parent.\n        result += hasAnd(nested) ? nested.replace(parentRegExp, parent) : parent + ' ' + nested;\n      }\n    }\n\n    return result;\n  }\n\n  function getOptions(rule, container, options) {\n    // Options has been already created, now we only increase index.\n    if (options) return _extends({}, options, { index: options.index + 1 });\n\n    var nestingLevel = rule.options.nestingLevel;\n\n    nestingLevel = nestingLevel === undefined ? 1 : nestingLevel + 1;\n\n    return _extends({}, rule.options, {\n      nestingLevel: nestingLevel,\n      index: container.indexOf(rule) + 1\n    });\n  }\n\n  function onProcessStyle(style, rule) {\n    if (rule.type !== 'style') return style;\n    var container = rule.options.parent;\n    var options = void 0;\n    var replaceRef = void 0;\n    for (var prop in style) {\n      var isNested = hasAnd(prop);\n      var isNestedConditional = prop[0] === '@';\n\n      if (!isNested && !isNestedConditional) continue;\n\n      options = getOptions(rule, container, options);\n\n      if (isNested) {\n        var selector = replaceParentRefs(prop, rule.selector\n        // Lazily create the ref replacer function just once for\n        // all nested rules within the sheet.\n        );if (!replaceRef) replaceRef = getReplaceRef(container\n        // Replace all $refs.\n        );selector = selector.replace(refRegExp, replaceRef);\n\n        container.addRule(selector, style[prop], _extends({}, options, { selector: selector }));\n      } else if (isNestedConditional) {\n        container\n        // Place conditional right after the parent rule to ensure right ordering.\n        .addRule(prop, null, options).addRule(rule.key, style[prop], { selector: rule.selector });\n      }\n\n      delete style[prop];\n    }\n\n    return style;\n  }\n\n  return { onProcessStyle: onProcessStyle };\n}"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}